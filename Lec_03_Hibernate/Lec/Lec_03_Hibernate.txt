* What is Hibernate 

    Hibernate е ORM framework, като ORM означава (Object-Relational Mapping)
    # ORM е начин, чрез който може да се преобразуват данните между несъвместими типови системи, примерно синхронизиране на данни между Java и релационна база данни RDBMS

    В една Java програма данните са моделирани в обекти, които си имат собствено поведение и състояние, тези обекти са временни и се намират в паметта на JVM
    За да можем да запазваме данните постоянно се използва релационна база данни (SQL базирана като MySQL, Postgres), като тук данните се съхраняват в таблици, редове и колони

    Ако не използваме ORM (тоест използвайки само JDBC) прехвърлянето на данните е по-голяма отговорност за програмиста, защото:
    - пишат се сурови sql заявки
    - ръчно трябва да се извличат данните от заявката 
    - трябва ръчно да се изпълнява заявката 
    # Без ORM един програмист трябва добре да владее SQL, за да може да извлича данни 

    Hibernate решава този проблема като автоматизира процеса на преобразуване, защото вместо да се пишат SQL заявкио, обектите се подават към Hibernate и framework-a генерирана SQL кода
    Този процес се случва чрез mapping между структурата на Java класа и структурата на базата данни:
    - Името на един Java клас служи за дефиниране на има на таблицата в базата данни 
    - Член-данните на класа са имена на колоните в таблицата, като типовете данни съще се съгласуват към SQL вариант-а
    - Всяка инстанция на обект се запазва с нейните данни като ред в тази таблица 

    Предимства на този подход:
    - Позволява абстракция на SQL
    - Позволява по-добра продуктивност и поддръжка, защото кода е по-чист и по-лесен за поддръжка
    - Hibernate автоматично се гружи за конфигурацията, в случай на промяна на базата данни 
    - Hibernate позволява вградени механизми за кеширане и оптимизация на заявките 

* Database mappings 

    Има три основни вида Mapping-и:
    - One-to-One
    - One-to-Many
    - Many-to-Many

    Когато се правят mapping-и ще са важни тези концепции:
    - Primary Key (PK) е уникален индентификатор за всеки ред в една таблица
    - Foreign Key (FK) е поле в една таблица, което сочи към PK на друга таблица 

    (One-to-One)
    Представлява строга връзка, като един запис от таблицата А се свързва с точнои един запис от Таблица Б
    За да реализираме това трябва таблица Б да има FK, който да сочи към PK на таблица А, но самата колона на FK при Б не трябва да има повтарящи се стойности

    (One-to-many)
    Един запис от таблица А може да бъде свързван с много записи от таблица Б, но запис от таблица Б принадлежи само на един запис от А 
    За да реализираме това трябва таблица Б да има FK, който да сочи към PK на таблица А, в колоната за FK на Б може да има повтарящи се стойности 

    (Many-to-Many)
    Един запис от таблица А може да се свърже с много записи от таблица Б и обратното
    За да се реализира това се създава нова таблица, която съдържа два FK, които сочат към отделните PK на таблиците 

* Eager/Lazy fetch 

    Session класа държи JDBC връзката към базата данните, когато се извикат неговите методи за запазване или извлючане на данни, той в background-a генерира sql командите към базата 

    (Eager fetching) 
    Използвайки FetchType.EAGER, Hibernate извлича свързаните данни незабавно, тоест Hibernate ще генерира SQL заявка, които извлича всичките данни за един запис
    # Това влючва и всичките данни на един FK 
    Плюс на този метод е че всичките даннин ще бъдат налични веднага 
    Минус на този метод е, че ако имаме много записи в базата данни, които ще извлечем, да не достигне място за тях да бъдат заредени в паметта 

    (Lazy fetching)
    Използвайки FetchType.Lazy, Hibernate ще вземе данните от базата само когато са поискани и междувременно използва Proxy
    Proxy е заместител на класът, за който трябва да вземем данни, който съдържа само id-то на записа, едва когато се извика някой метод върху proxy-то ще се извлече цялата информация 
    Плюс е че пести много памет както и CPU ресурси
    Минус е че може да се случи N+1 проблема или да се хвърли LazyInitializationException

    N+1 се случва, ако примерно искаме да вземем 10 данни (обекта) от базата и после, ако ги итерираме всичките Hibernate ще трябва да направи 10 отделни заявким за всеки извикан метод
    
* LV1 и LV2 caching 

    Кешинирането се използва, за да се минимализира броя на скъпите заявки към базата данни, като има два вида кеширане в Hibernate:
    - LV1 caching
    - LV2 caching

    (LV1 caching)
    LV1 caching е задължителен и се използва автоматично в Hibernete като той е свързан с Sessionb обекта:
    - Този caching работи само докато е отворена сесията чрез Session, но когато се затвори сесията кешът се унищожава
    - Представлява вътрешен Map (Identity Map) като ключът е Primary Key/ID на entity–то, докато неговата стойност и самият Java Обект
    - Когато в един Session се поиска отново същото entity, вместо да се прави заявката ще се вземе обекта от Identity Map-a 

    (LV2 caching)
    LV2 кешът се намира на ниво SessionFactory, като има следните характеристики:
    - Всички сесия създадени от факторито споделят един и същи кеш
    - Докато LV1 зарежда Java инстанции, K2 съхранява dehydrated състояние, тоест масиви от стрингове, числа или примитиви, представляващи колоните в базата
    - Процеса на работа би следвал да се вземат дехидратираните данни, да се създаде нов Java обект с тези данни и да се сложи в LV1 кеша на текущата сесия
    
* HQL (Hibernate Query Language)

    HQL е обектно-ориентиран query language, който прилича на SQL, но работи върху Entity модела, а не върху схемата на базата данни 

    Hibernate позволява да се пишат SQL заявки, ако е необходимо (наричани още Native SQL), но HQL пише заявки към Java класове и техните полета и автоматично генерира SQL
    При HQL може да се посочи FROM STUDENT, тогава тази заявка казва на Hibernate че ни трябва всички обекти от тип Stydent 


    